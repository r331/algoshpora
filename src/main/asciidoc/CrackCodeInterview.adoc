= A set of basic algorithms for a job interview at a decent company
:imagesdir: images
:source-highlighter: highlightjs
:toc: left
:toclevels: 4

== Decent algorithms
image::img.png[decent weed (c) South Park]

== Arrays & hash functions

=== Contains Duplicate
Link: https://leetcode.com/problems/contains-duplicate/

Given an integer array _nums_, return _true_ if any value appears *at least twice* in the array,
and return _false_ if every element is distinct.

[source,java]
----
public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
        for(int i = 0; i < nums.length; i++){
            if(set.contains(nums[i]))
            return true;
            set.add(nums[i]);
        }
        return false;
    }
----

=== Valid Anagram
Link: https://leetcode.com/problems/valid-anagram/

Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase,
typically using all the original letters exactly once.

[source,java]
----
public boolean isAnagram(String s, String t) {
        // s & t has only a-z
        // s should == t
        if(s.length() != t.length()) return false;

        int [] letters = new int[26];
        for(int i = 0; i < s.length(); i++){
            letters[s.charAt(i) - 'a']++;
            letters[t.charAt(i) - 'a']--;
        }

        for(int i = 0; i < 26; i++){
            if(letters[i]!=0)
            return false;
        }
        return true;
    }
----

=== Two Sum
Link: https://leetcode.com/problems/two-sum/

[source, java]
----
public int[] twoSum(int[] nums, int target) {
        var map = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey((target - nums[i])))
                return new int[]{map.get(target - nums[i]), i};
            map.put(nums[i], i);
        }
        return new int[0];
    }
----

=== Group Anagrams
Link: https://leetcode.com/problems/group-anagrams/

[source, java]
----
public List<List<String>> groupAnagrams(String[] strs) {
        // we have a-z
        // str!=null, str size > 0

        Map<String, List<String>> map = new HashMap<>();

        for(String s : strs){
            char[] chars = s.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);
            if(map.containsKey(key)){
                map.get(key).add(s);
            }else{
                var lst = new ArrayList<String>();
                lst.add(s);
                 map.put(key, lst);

            }

        }
        return map.values().stream().toList();
    }
----

=== Top K Frequent Elements
Link: https://leetcode.com/problems/top-k-frequent-elements/

Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.

[source, java]
----
public int[] topKFrequent(int[] nums, int k) {
        // sort -> place it in TreeMap (or Sort Stack)
        Map<Integer, Integer> map = new HashMap<>();
        for(int i =0; i < nums.length; i++){
            if(map.containsKey(nums[i])){
                map.put(nums[i], map.get(nums[i]) + 1);
            }
            else{
                map.put(nums[i], 1);
            }
        }
          Queue<Integer> heap = new PriorityQueue<>(
            (n1, n2) -> map.get(n1) - map.get(n2));

           for (int n: map.keySet()) {
          heap.add(n);
          if (heap.size() > k) heap.poll();
        }

        return heap.stream().mapToInt(x -> x).toArray();
    }
----

===


[source, java]
----
----